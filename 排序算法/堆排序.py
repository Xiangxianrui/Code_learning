#堆：一个类似利用一个类似树的结构存数据和排序
#树节点关系：父节点j,子节点 j=2*i+1
'''
堆：一种特殊的二叉树
大根堆：父节点比子节点大
小根堆：子节点比父节点

整体思路：
1.构造一个大根堆
2.取堆顶元素未最大数
3.将最后一个元素放到最堆顶位置
4。向下调整
5.重复 2,3,4

'''
#向下调整--------------------------1
def sift(li,low,high):
    '''

    :param li:列表
    :param low: 根节点位置
    :param high: 堆的最后一个元素的位置
    :return:
    '''
    #i:某一层的父节点 j:下一层的子节点。  两个数分别向下，然后对比大小，换数
    i=low#最开始，i 指向根节点
    j=2*i+1
    tmp=li[low]#把堆顶元素存起来
    while j<=high: #只要没有越界------每次赋值完成后都要回到这里
        if j+1<=high and li[j]<li[j+1]:#存在右孩子，而且右孩子比较大————————保证上位的是较大的子节点
            j=j+1#把指针指向右节点，比较较大的右节点
        if li[j]>tmp:
            li[i]=li[j]#把这个大的数放到堆顶的位置
            i=j#指针 i 继续向下，tmp 向下比较，放到合适位置     只要不越界，自动向下遍历
            j=2*i+1#j也向下移动
        else:
            li[i]=tmp
            break
    else:
        li[i]=tmp#指针 i 到了最后一层，j 越界了，此时的位置就是 i 应该留下的最底层的位置，直接赋值
'''
整个向下循环的过程通过 while 循环和 i，j 重复向下赋值控制
while条件控制是得整个循环都在数列中进行
if 循环，如果不成立，说明根节点够大，不需要更换，直接赋值回来  如果成立，说明根节点太小了，较大的子节点上位到父节点位置，在这种情况下，i，j 再次赋值，更下深入向下

在图中是一个交换的过程，但在实际上是一个利用 i，j，下面的数不断覆盖上面的数的过程。每个过程中只和 tmp 比较

变得只是指针的位置，每个数的索引没有发生变化

函数的作用是将除了堆顶，其他地方都符合大根堆的一个堆调整成一个大根堆（调整堆顶的数）

'''

#向上调整构造堆
def heap_sort(li):
    n=len(li)
    for i in range((n-2)//2,-1,-1):#sift函数第一个参数是某个堆的堆顶，（k-1）/2是扣个子节点的父节点，最后一个数的索引是 k-1,所以他的父节点为 （k-2）//2
        sift(li,i,n-1)
    for i in range(n-1,-1,-1):#从最后一个数到第一个数，倒着走（因该一直取到第一个元素，也就是索引为 0 的元素，那就是要停在索引为-1的数之前）
        li[i],li[0]=li[0],li[i]#同时实现两步 1.将较大的数放到数列后面 2.将最小的数放到堆顶位置
        sift(li,0,i-1)#对调整过后的新变了范围的大根堆进行调整
list1=[i for i in range(100)]
import random as rd
rd.shuffle(list1)
print(f'打乱后：{list1}')
print(len(list1))
heap_sort(list1)
print(f'排序后：{list1}')


'''
时间复杂度：nlog(n)
sift函数的时间复杂度为 log（n）
一个 for 循环的时间复杂度为 n，算起来就是 nlog（n）
两个 for 循环叠在一起就是 2nlog（n）-------nlog（n）


'''

import heapq








